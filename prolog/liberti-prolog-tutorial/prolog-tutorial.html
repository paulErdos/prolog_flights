<BASE HREF="http://cs.wwc.edu/~cs_dept/KU/PR/">
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>Prolog Tutorial</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.01Gold (X11; I; Linux 2.0.30 i686) [Netscape]">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<P>
<HR></P>

<H1 ALIGN=CENTER>Prolog Tutorial</H1>

<P>J. A. Robinson: A program is a theory (in some logic) and computation
is deduction from the theory.<BR>
N. Wirth: Program = data structure + algorithm<BR>
R. Kowalski: Algorithm = logic + control 
<HR></P>

<DL>
<DT><B>Introduction to Prolog</B> </DT>

<DL>
<DT><A HREF="#intro">Introduction</A> </DT>

<DT><A HREF="#struc">The Structure of Prolog Program</A> </DT>

<DL>
<DT><A HREF="#syntax">Syntax</A> </DT>
</DL>

<DT><A HREF="#types">Types</A> </DT>

<DL>
<DT><A HREF="#simple">Simple</A> </DT>

<DT><A HREF="#composite">Composite</A> </DT>
</DL>

<DT><A HREF="#expr">Expressions</A> </DT>

<DT><A HREF="#pat">Unification and Pattern Matchine</A> </DT>

<DT><A HREF="#fun">Functions</A> </DT>

<DT><A HREF="#list">Lists</A> </DT>

<DT><A HREF="#iteration">Iteration</A> </DT>

<DT><A HREF="#itgenback">Iterators, Generators and Backtracking</A> </DT>

<DT><A HREF="#tuples">Tuples</A> </DT>

<DT><A HREF="#extralogical">Extra-Logical Predicates</A> </DT>

<DL>
<DT><A HREF="#io">Input/Output</A> </DT>
</DL>

<DT><A HREF="#style">Style and Layout</A> </DT>
</DL>

<DT><B>Applications &amp; Advanced Programming Techniques</B> </DT>

<DL>
<DT><A HREF="#negation">Negation and Cuts</A> </DT>

<DT><A HREF="#dcg">Definite Clause Grammars</A> </DT>

<DT><A HREF="#inc">Incomplete Data Structures</A> </DT>

<DT><A HREF="#meta">Meta Level Programming</A> </DT>

<DT><A HREF="#2ndOrder">Second-Order Programming</A> </DT>

<DT><A HREF="#database">Database</A> </DT>

<DT><A HREF="#expert">Expert Systems</A> </DT>

<DT><A HREF="#oop">Object-Oriented Programming</A> </DT>
</DL>

<DT><A HREF="#appendix">Appendix</A> </DT>

<DT><A HREF="#ref">References</A> </DT>
</DL>

<H2><A NAME="intro"></A>Introduction</H2>

<P>Prolog, which stands for PROgramming in LOGic, is the most widely available
language in the logic programming paradigm. Logic and therefore Prolog
is based the mathematical notions of relations and logical inference. Prolog
is a declarative language meaning that rather than describing how to compute
a solution, a program consists of a data base of facts and logical relationships
(rules) which describe the relationships which hold for the given application.
Rather then running a program to obtain a solution, the user asks a question.
When asked a question, the run time system searches through the data base
of facts and rules to determine (by logical deduction) the answer. </P>

<P>Among the features of Prolog are `logical variables' meaning that they
behave like mathematical variables, a powerful pattern-matching facility
(unification), a backtracking strategy to search for proofs, uniform data
structures, and input and output are interchangeable. </P>

<P>Often there will be more than one way to deduce the answer or there
will be more than one solution, in such cases the run time system may be
asked find other solutions. backtracking to generate alternative solutions.
Prolog is a weakly typed language with dynamic type checking and static
scope rules. </P>

<P>Prolog is used in artificial intelligence applications such as natural
language interfaces, automated reasoning systems and expert systems. Expert
systems usually consist of a data base of facts and rules and an inference
engine, the run time system of Prolog provides much of the services of
an inference engine. </P>

<H2><A NAME="struc"></A>The Structure of Prolog Programs</H2>

<UL>
<LI>A Prolog program consists of a database of facts and rules, and queries
(questions). </LI>

<UL>
<LI>Fact: ... . </LI>

<LI>Rule: ... :- ... . </LI>

<LI>Query: ?- ... . </LI>

<LI>Variables: must begin with an upper case letter. </LI>

<LI>Constants: numbers, begin with lowercase letter, or enclosed in single
quotes. </LI>
</UL>

<LI>Inductive definitions: base and inductive cases </LI>

<UL>
<LI>Towers of Hanoi: move N disks from pin a to pin b using pin c. </LI>

<TABLE>
<TR>
<TD>hanoi(N)</TD>

<TD>:-</TD>

<TD>hanoi(N, a, b, c). </TD>
</TR>

<TR>
<TD>hanoi(0,_,_,_).</TD>
</TR>

<TR>
<TD>hanoi(N,FromPin,ToPin,UsingPin)</TD>

<TD>:-</TD>

<TD>M is N-1,</TD>
</TR>

<TR>
<TD></TD>

<TD></TD>

<TD>hanoi(M,FromPin,UsingPin,ToPin),</TD>
</TR>

<TR>
<TD></TD>

<TD></TD>

<TD>move(FromPin,ToPin),</TD>
</TR>

<TR>
<TD></TD>

<TD></TD>

<TD>hanoi(M,UsingPin,ToPin,FromPin).</TD>
</TR>

<TR>
<TD>move(From,To)</TD>

<TD>:-</TD>

<TD>write([move, disk from, pin, From, to, pin, ToPin]),</TD>
</TR>

<TR>
<TD></TD>

<TD></TD>

<TD>nl.</TD>
</TR>
</TABLE>

<LI>Lists: append, member </LI>

<TABLE>
<TR>
<TD>list([]).</TD>
</TR>

<TR>
<TD>list([X|L])</TD>

<TD>:-</TD>

<TD>[list(L).</TD>
</TR>

<TR>
<TD>Abbrev:</TD>

<TD></TD>

<TD>[X<SUB>1</SUB>|[...[X<SUB>n</SUB>|[]...] = [X<SUB>1</SUB>,...X<SUB>n</SUB>]</TD>
</TR>

<TR>
<TD>append([],L,L).</TD>
</TR>

<TR>
<TD>append([X|L1],L2,[X|L12])</TD>

<TD>:-</TD>

<TD>append(L1,L2,L12).</TD>
</TR>

<TR>
<TD>member(X,L)</TD>

<TD>:-</TD>

<TD>concat(_,[X|_],L).</TD>
</TR>
</TABLE>

<LI>Ancestor </LI>

<TABLE>
<TR>
<TD>ancestor(A,D)</TD>

<TD>:-</TD>

<TD>parent(A,B).</TD>
</TR>

<TR>
<TD>ancestor(A,D)</TD>

<TD>:-</TD>

<TD>parent(A,C),ancestor(C,D).</TD>
</TR>

<TR>
<TD><I>but not</I></TD>
</TR>

<TR>
<TD>ancestor(A,D)</TD>

<TD>:-</TD>

<TD>ancestor(A,P), parent(P,D).</TD>
</TR>
</TABLE>

<P><I>since infinite recursion may result.</I> </P>
</UL>

<LI>Depth-first search: Maze/Graph traversal<BR>
A database of arcs (we will assume they are directed arcs) of the form:
</LI>

<TABLE>
<TR>
<TD>a(node_i,node_j).</TD>

<TD></TD>

<TD></TD>
</TR>
</TABLE>

<P>Rules for searching the graph: </P>

<TABLE>
<TR>
<TD>go(From,To,Trail).</TD>

<TD></TD>

<TD></TD>
</TR>

<TR>
<TD>go(From,To,Trail)</TD>

<TD>:-</TD>

<TD>a(From,In), not visited(In,Trail), go(In,To,[In|Trail]).</TD>
</TR>

<TR>
<TD>visited(A,T)</TD>

<TD>:-</TD>

<TD>member(A,T).</TD>
</TR>
</TABLE>

<LI>I/O: terms, characters, files, lexical analyzer/scanner </LI>

<UL>
<LI>read(T), write(T), nl. </LI>

<LI>get0(N), put(N): ascii value of character </LI>

<LI>name(Name,Ascii_list). </LI>

<LI>see(F), seeing(F), seen, tell(F), telling(F), told. </LI>
</UL>

<LI>Natural language processing: Context-free grammars may be represented
as Prolog rules. For example, the rule </LI>

<TABLE>
<TR>
<TD>sentence</TD>

<TD>::=</TD>

<TD>noun_clause verb_clause</TD>
</TR>
</TABLE>

<P><I>can be implemented in Prolog as</I> </P>

<TABLE>
<TR>
<TD>sentence(S)</TD>

<TD>:-</TD>

<TD>append(NC,VC,S), noun_clause(NC), verb_clause(VC).</TD>
</TR>

<TR>
<TD><I>or in DCG as:</I></TD>
</TR>

<TR>
<TD>sentence</TD>

<TD>-&gt;</TD>

<TD>noun_clause, verb_clause.</TD>
</TR>

<TR>
<TD>?- sentence(S,[]).</TD>
</TR>
</TABLE>

<P>Note that two arguments appear in the query. Both are lists and the
first is the sentence to be parsed, the second the remaining elements of
the list which in this case is empty. </P>
</UL>

<P>A Prolog program consists of a data base of facts and rules. There is
no structure imposed on a Prolog program, there is no main procedure, and
there is no nesting of definitions. All facts and rules are global in scope
and the scope of a variable is the fact or rule in which it appears. The
readability of a Prolog program is left up to the programmer. </P>

<P>A Prolog program is executed by asking a question. The question is called
a query. Facts, rules, and queries are called <I>clauses</I>. </P>

<H2><A NAME="syntax"></A>Syntax</H2>

<H3><A NAME="facts"></A>Facts</H3>

<P>A <B>fact</B> is just what it appears to be --- a fact. A fact in everyday
language is often a proposition like ``It is sunny.'' or ``It is summer.''
In Prolog such facts could be represented as follows: </P>

<BLOCKQUOTE>
<PRE>'It is sunny'.
'It is summer'.
</PRE>
</BLOCKQUOTE>

<H3><A NAME="queries"></A>Queries</H3>

<P>A <B>query</B> in Prolog is the action of asking the program about information
contained within its data base. Thus, queries usually occur in the interactive
mode. After a program is loaded, you will receive the query prompt, </P>

<BLOCKQUOTE>
<PRE>   ?- 
</PRE>
</BLOCKQUOTE>

<P>at which time you can ask the run time system about information in the
data base. Using the simple data base above, you can ask the program a
question such as </P>

<BLOCKQUOTE>
<PRE>   ?- 'It is sunny'.
</PRE>
</BLOCKQUOTE>

<P>and it will respond with the answer </P>

<BLOCKQUOTE>
<PRE>   Yes
   ?- 
</PRE>
</BLOCKQUOTE>

<P>A <TT>yes</TT> means that the information in the data base is consistent
with the subject of the query. Another way to express this is that the
program is capable of proving the query true with the available information
in the data base. If a fact is not deducible from the data base the system
replys with a no, which indicates that based on the information available
(the closed world assumption) the fact is not deducible. </P>

<P>If the data base does not contain sufficient information to answer a
query, then it answers the query with a no. </P>

<BLOCKQUOTE>
<PRE>   ?- 'It is cold'.
   no
   ?-
</PRE>
</BLOCKQUOTE>

<H3><A NAME="rules"></A>Rules</H3>

<P><B>Rules</B> extend the capabilities of a logic program. They are what
give Prolog the ability to pursue its decision-making process. The following
program contains two rules for temperature. The first rule is read as follows:
``It is hot if it is summer and it is sunny.'' The second rule is read
as follows: ``It is cold if it is winter and it is snowing.'' </P>

<BLOCKQUOTE>
<PRE>'It is sunny'.
'It is summer'.
'It is hot' :- 'It is summer', 'It is sunny'.
'It is cold' :- 'It is winter', 'It is snowing'.
</PRE>
</BLOCKQUOTE>

<P>The query, </P>

<BLOCKQUOTE>
<PRE>   ?- 'It is hot'.
   Yes
   ?- 
</PRE>
</BLOCKQUOTE>

<P>is answered in the affirmative since both 'It is summer' and 'It is
sunny' are in the data base while a query ``?- 'It is cold.' '' will produce
a negative response. </P>

<P>The previous program is an example of propositional logic. Facts and
rules may be parameterized to produce programs in predicate logic. The
parameters may be variables, atoms, numbers, or terms. Parameterization
permits the definition of more complex relationships. The following program
contains a number of predicates that describe a family's genelogical relationships.
</P>

<BLOCKQUOTE>
<PRE>   female(amy).
   female(johnette).
   
   male(anthony).
   male(bruce).
   male(ogden).

   parentof(amy,johnette).
   parentof(amy,anthony).
   parentof(amy,bruce).
   parentof(ogden,johnette).
   parentof(ogden,anthony).
   parentof(ogden,bruce).
  
</PRE>
</BLOCKQUOTE>

<P>The above program contains the three simple predicates: <TT>female</TT>;
<TT>male</TT>; and <TT>parentof</TT>. They are parameterized with what
are called `atoms.' There are other family relationships which could also
be written as facts, but this is a tedious process. Assuming traditional
marriage and child-bearing practices, we could write a few rules which
would relieve the tedium of identifying and listing all the possible family
relations. For example, say you wanted to know if <TT>johnette</TT> had
any siblings, the first question you must ask is ``what does it mean to
be a sibling?'' To be someone's sibling you must have the same parent.
This last sentence can be written in Prolog as </P>

<BLOCKQUOTE>
<PRE>siblingof(X,Y) :- 
            parentof(Z,X),
            parentof(Z,Y).
</PRE>
</BLOCKQUOTE>

<P>A translation of the above Prolog rule into English would be ``X is
the sibling of Y provided that Z is a parent of X, and Z is a parent of
Y.'' <TT>X, Y,</TT> and <TT>Z</TT> are variables. This rule however, also
defines a child to be its own sibling. To correct this we must add that
<TT>X</TT> and <TT>Y</TT> are not the same. The corrected version is: </P>

<BLOCKQUOTE>
<PRE>siblingof(X,Y) :- 
            parentof(Z,X),
            parentof(Z,Y),
            X  Y.
</PRE>
</BLOCKQUOTE>

<P>The relation <TT>brotherof</TT> is similar but adds the condition that
<TT>X</TT> must be a male. </P>

<BLOCKQUOTE>
<PRE>brotherof(X,Y) :- 
            parentof(Z,X),
            male(X),
            parentof(Z,Y),
            X  Y.
</PRE>
</BLOCKQUOTE>

<P>From these examples we see how to construct facts, rules and queries
and that strings are enclosed in single quotes, variables begin with a
capital letter, constants are either enclosed in single quotes or begin
with a small letter. </P>

<H2><A NAME="types"></A>Types</H2>

<P>Prolog provides for numbers, atoms, lists, tuples, and patterns. The
types of objects that can be passed as arguments are defined in this section.
</P>

<H3><A NAME="simple"></A>Simple Types</H3>

<P>Simple types are implementation dependent in Prolog however, most implementations
provide the simple types summarized in the following table. </P>

<CENTER><TABLE>
<TR>
<TD>TYPE </TD>

<TD>VALUES </TD>
</TR>

<TR>
<TD>boolean </TD>

<TD>true, fail </TD>
</TR>

<TR>
<TD>integer </TD>

<TD>integers </TD>
</TR>

<TR>
<TD>real </TD>

<TD>floating point numbers </TD>
</TR>

<TR>
<TD>variable </TD>

<TD>variables </TD>
</TR>

<TR>
<TD>atom </TD>

<TD>character sequences </TD>
</TR>
</TABLE></CENTER>

<P>The boolean constants are not usually passed as parameters but are propositions.
The constant <TT>fail</TT> is useful in forcing the generation of all solutions.
Variables are character strings beginning with a capital letter. Atoms
are either quoted character strings or unquoted strings beginning with
a small letter. </P>

<H3><A NAME="composite"></A>Composite Types</H3>

<P>In Prolog the distinction between programs and data are blurred. Facts
and rules are used as data and data is often passed in the arguments to
the predicates. Lists are the most common data structure in Prolog. They
are much like the array in that they are a sequential list of elements,
and much like the stack in that you can only access the list of elements
sequentially, that is, from one end only and not in random order. In addition
to lists Prolog permits arbitrary patterns as data. The patterns can be
used to represent tuples. Prolog does not provide an array type. But arrays
may be represented as a list and multidimensional arrays as a list(s) of
lists. An alternate representation is to represent an array as a set of
facts in a the data base. </P>

<CENTER><TABLE>
<CAPTION>
<CENTER><P>TYPE </P></CENTER>
</CAPTION>

<TR>
<TD>REPRESENTATION <BR>
list </TD>

<TD>[ <I>comma separated sequence of items</I> ] <BR>
pattern </TD>

<TD><I>sequence of items</I> <BR>
</TD>
</TR>
</TABLE></CENTER>

<P>A list is designated in Prolog by square brackets ([ ]+). An example
of a list is </P>

<BLOCKQUOTE>
<PRE>[dog,cat,mouse]
</PRE>
</BLOCKQUOTE>

<P>This says that the list contains the elements <TT>dog</TT>, {\tt cat,
and <TT>mouse</TT>, in that order. Elements in a Prolog list are ordered,
even though there are no indexes. Records or tuples are represented as
patterns. Here is an example. </P>

<BLOCKQUOTE>
<PRE>book(author(aaby,anthony),title(lab<SUB>m</SUB>anual),data(1991))
</PRE>
</BLOCKQUOTE>

<P>The elements of a tuple are accessed by pattern matching. </P>

<BLOCKQUOTE>
<PRE>book(Title,Author,Publisher,Date).
author(LastName,FirstName,MI).
publisher(Company,City).
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>book(T,A,publisher(C,rome),Date)
</PRE>
</BLOCKQUOTE>

<H3><A NAME=""></A>Type Predicates</H3>

<P>Since Prolog is a weakly typed language, it is important for the user
to be able to determine the type of a parameter. The following built in
predicates are used to determine the type of a parameter. </P>

<CENTER><TABLE>
<TR>
<TD>PREDICATE </TD>

<TD>CHECKS IF </TD>
</TR>

<TR>
<TD>var(V) </TD>

<TD>V is a variable </TD>
</TR>

<TR>
<TD>nonvar(NV) </TD>

<TD>NV is not a variable </TD>
</TR>

<TR>
<TD>atom(A) </TD>

<TD>A is an atom </TD>
</TR>

<TR>
<TD>integer(I) </TD>

<TD>I is an integer </TD>
</TR>

<TR>
<TD>real(R) </TD>

<TD>R is a floating point number </TD>
</TR>

<TR>
<TD>number(N) </TD>

<TD>N is an integer or real </TD>
</TR>

<TR>
<TD>atomic(A) </TD>

<TD>A is an atom or a number </TD>
</TR>

<TR>
<TD>functor(T,F,A) </TD>

<TD>T is a term with functor F and arity A </TD>
</TR>

<TR>
<TD>T =..L </TD>

<TD>T is a term, L is a list (see example below). </TD>
</TR>

<TR>
<TD>clause(H,T) </TD>

<TD>H :- T is a rule in the program </TD>
</TR>
</TABLE></CENTER>

<P>The last three are useful in program manipulation (metalogical or meta-programming)
and require additional explanation. <TT>clause(H,T)</TT> is used to check
the contents of the data base. <TT>functor(T,F,A)</TT> and <TT>T=..L</TT>
are used to manipulate terms. The predicate, <TT>functor</TT> is used as
follows. </P>

<BLOCKQUOTE>
<PRE>functor(T,F,A)
</PRE>
</BLOCKQUOTE>

<P><TT>T</TT> is a term, <TT>F</TT> is its functor, and <TT>A</TT> is its
arity. For example, </P>

<BLOCKQUOTE>
<PRE>?- functor(t(a,b,c),F,A).
F = t
A = 3
yes
</PRE>
</BLOCKQUOTE>

<P><TT>t</TT> is the functor of the term <TT>t(a,b,c)</TT>, and 3 is the
arity (number of arguments) of the term. The predicate <TT>=..</TT> (univ)
is used to compose and decompose terms. For example: </P>

<BLOCKQUOTE>
<PRE>?- t(a,b,c) =..L.
L = [t,a,b,c]
yes
?- T =..[t,a,b,c].
T = t(a,b,c)
yes
</PRE>
</BLOCKQUOTE>

<H2><A NAME="expr"></A>Expressions</H2>

<P>Arithmetic expressions are evaluated with the built in predicate <TT>is</TT>
which is used as an infix operator in the following form. </P>

<BLOCKQUOTE>
<PRE><I>variable</I> is <I>expression</I>
</PRE>
</BLOCKQUOTE>

<P>For example, </P>

<BLOCKQUOTE>
<PRE>?- X is 3*4.
X = 12
yes
</PRE>
</BLOCKQUOTE>

<H3><A NAME=""></A>Arithmetic Operators</H3>

<P>Prolog provides the standard arithmetic operations as summarized in
the following table. </P>

<CENTER><TABLE>
<TR>
<TD>SYMBOL </TD>

<TD>OPERATION </TD>
</TR>

<TR>
<TD>+ </TD>

<TD>addition </TD>
</TR>

<TR>
<TD>- </TD>

<TD>subtraction </TD>
</TR>

<TR>
<TD>* </TD>

<TD>multiplication </TD>
</TR>

<TR>
<TD>/ </TD>

<TD>real division </TD>
</TR>

<TR>
<TD>// </TD>

<TD>integer division </TD>
</TR>

<TR>
<TD>mod </TD>

<TD>modulus </TD>
</TR>

<TR>
<TD>** </TD>

<TD>power </TD>
</TR>
</TABLE></CENTER>

<H3><A NAME=""></A>Boolean Predicates</H3>

<P>Besides the usual boolean predicates, Prolog provides more general comparison
operators which compare terms and predicates to test for unifiability and
whether terms are identical. </P>

<CENTER><TABLE>
<TR>
<TD>SYMBOL </TD>

<TD>OPERATION </TD>

<TD>ACTION </TD>
</TR>

<TR>
<TD>A ?= B </TD>

<TD>unifiable </TD>

<TD>A and B are unifiable but </TD>

<TD></TD>

<TD>does not unify A and B </TD>
</TR>

<TR>
<TD>A = B </TD>

<TD>unify </TD>

<TD>unifys A and B if possible </TD>
</TR>

<TR>
<TD>A \+= B </TD>

<TD>not unifiable </TD>

<TD></TD>
</TR>

<TR>
<TD>A == B </TD>

<TD>identical </TD>

<TD>does not unify A and B </TD>
</TR>

<TR>
<TD>A \+== B </TD>

<TD>not identical </TD>

<TD></TD>
</TR>

<TR>
<TD>A =:= B </TD>

<TD>equal (value) </TD>

<TD>evaluates A and B to </TD>

<TD></TD>

<TD>determine if equal </TD>
</TR>

<TR>
<TD>A =\+= B </TD>

<TD>not equal (value) </TD>

<TD></TD>
</TR>

<TR>
<TD>A &lt; B </TD>

<TD>less than (numeric) </TD>

<TD></TD>
</TR>

<TR>
<TD>A =&lt; B </TD>

<TD>less or equal (numeric)</TD>

<TD></TD>
</TR>

<TR>
<TD>A &gt; B </TD>

<TD>greater than (numeric)</TD>

<TD></TD>
</TR>

<TR>
<TD>A &gt;= B </TD>

<TD>greater or equal (numeric)</TD>

<TD></TD>
</TR>

<TR>
<TD>A @&lt; B </TD>

<TD>less than (terms) </TD>

<TD></TD>
</TR>

<TR>
<TD>A @=&lt; B </TD>

<TD>less or equal (terms) </TD>

<TD></TD>
</TR>

<TR>
<TD>A @&gt; B </TD>

<TD>greater than (terms) </TD>

<TD></TD>
</TR>

<TR>
<TD>A @&gt;= B </TD>

<TD>greater or equal (terms) </TD>

<TD></TD>
</TR>
</TABLE></CENTER>

<P>For example, the following are all true. </P>

<BLOCKQUOTE>
<PRE>3 @&lt; 4
3 @&lt; a
a @&lt; abc6
abc6 @&lt; t(c,d)
t(c,d) @&lt; t(c,d,X)
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of natural number. </P>

<BLOCKQUOTE>
<PRE>% natural_number(N) &lt;- N is a natural number.

natural_number(0).
natural_number(s(N)) :- natural_number(N).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of natural number. </P>

<BLOCKQUOTE>
<PRE>natural_number(N) :- integer(N), N &gt;= 0.
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of inequalities </P>

<BLOCKQUOTE>
<PRE>% less_than(M,N) &lt;- M is less than M

less_than(0,s(M)) :- natural_number(M).
less_than(s(M),s(N)) :- less_than(M,N).

% less_than_or_equal(M,N) &lt;- M is less than or equal to M

less_than_or_equal(0,N) :- natural_number(N).
less_than_or_equal(s(M),s(N)) :- less_than_or_equal(M,N).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of inequality. </P>

<BLOCKQUOTE>
<PRE>M =&lt; N.
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of addition/substraction </P>

<BLOCKQUOTE>
<PRE>% plus(X,Y,Z) &lt;- Z is X + Y

plus(0,N,N) :- natural_number(N).
plus(s(M),N,s(Z)) :- plus(M,N,Z).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of addition </P>

<BLOCKQUOTE>
<PRE>plus(M,N,Sum) :- Sum is M+N.
</PRE>
</BLOCKQUOTE>

<P>This does not define substration. Logic programming definition of multiplication/division
</P>

<BLOCKQUOTE>
<PRE>% times(X,Y,Z) &lt;- Z is X*Y 

times(0,N,0) :- natural_number(N).
times(s(M),N,Z) :- times(M,N,W), plus(W,N,Z).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of multiplication. </P>

<BLOCKQUOTE>
<PRE>times(M,N,Product) :- Product is M*N.
</PRE>
</BLOCKQUOTE>

<P>This does not define substration. Logic programming definition of Exponentiation
</P>

<BLOCKQUOTE>
<PRE>% exp(N,X,Z) &lt;- Z is X**N

exp(s(M),0,0) :- natural_number(M).
exp(0,s(M),s(0)) :- natural_number(M).
exp(s(N),X,Z) :- exp(N,X,Y), times(X,Y,Z).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of exponentiation is implementation dependent. </P>

<H3><A NAME=""></A>Logical Operators</H3>

<P>Predicates are functions which return a boolean value. Thus the logical
operators are built in to the language. The comma on the right hand side
of a rule is logical conjunction. The symbol <TT>:-</TT> is logical implication.
In addition Prolog provides negation and disjunction operators. The logical
operators are used in the definition of rules. Thus, </P>

<CENTER><TABLE>
<TR>
<TD>a :- b. % a if b </TD>
</TR>

<TR>
<TD>a :- b,c. % a if b and c. </TD>
</TR>

<TR>
<TD>a :- b;c. % a if b or c. </TD>
</TR>

<TR>
<TD>a :- \++ b. % a if b is not provable </TD>
</TR>

<TR>
<TD>a :- not b. % a if b fails </TD>
</TR>

<TR>
<TD>a :- b -&gt; c;d. % a if (if b then c else d) </TD>
</TR>
</TABLE></CENTER>

<P>This table summarizes the logical operators. </P>

<CENTER><TABLE>
<TR>
<TD>SYMBOL </TD>

<TD>OPERATION </TD>
</TR>

<TR>
<TD>not </TD>

<TD>negation </TD>
</TR>

<TR>
<TD>\+ </TD>

<TD>not provable </TD>
</TR>

<TR>
<TD>, </TD>

<TD>logical conjunction </TD>
</TR>

<TR>
<TD>; </TD>

<TD>logical disjunction </TD>
</TR>

<TR>
<TD>:- </TD>

<TD>logical implication </TD>
</TR>

<TR>
<TD>-&gt; </TD>

<TD>if-then-else </TD>
</TR>
</TABLE></CENTER>

<H2><A NAME="pat"></A>Unification and Pattern Matching</H2>

<P>The arguments in a query are matched (or unified in Prolog terminology)
to select the appropriate rule. Here is an example which makes extensive
use of pattern matching. The rules for computing the derivatives of polynomial
expressions can be written as Prolog rules. A given polynomial expression
is matched against the first argument of the rule and the corresponding
derivative is returned. </P>

<BLOCKQUOTE>
<PRE>% deriv(<I>Polynomial</I>, <I>variable</I>, <I>derivative</I>)
% dc/dx = 0
deriv(C,X,0) :- number(C). 
% dx/dx} = 1
deriv(X,X,1).
% d(cv)/dx = c(dv/dx)
deriv(C*U,X,C*DU) :- number(C), deriv(U,X,DU).
% d(u v)/dx = u(dv/dx) + v(du/dx)
deriv(U*V,X,U*DV + V*DU) :- deriv(U,X,DU), deriv(V,X,DV).
% d(u &plusmn; v)/dx = du/dx &plusmn; dv/dx
deriv(U+V,X,DU+DV) :- deriv(U,X,DU), deriv(V,X,DV).
deriv(U-V,X,DU-DV) :- deriv(U,X,DU), deriv(V,X,DV).
% du^n/dx = nu^{n-1}(du/dx)
deriv(U^+N,X,N*U^+N1*DU) :- N1 is N-1, deriv(U,X,DU).
</PRE>
</BLOCKQUOTE>

<P>Prolog code is often bidirectional. In bidirectional code, the arguments
may be use either for input or output. For example, this code may be used
for both differentiation and integration with queries of the form: </P>

<BLOCKQUOTE>
<PRE>?- deriv(<I>Integral</I>,<I>X</I>,<I>Derivative</I>).
</PRE>
</BLOCKQUOTE>

<P>where either <I>Integral</I> or <I>Derivative</I> may be instantiated
to a formula. </P>

<H2><A NAME="fun"></A>Functions</H2>

<P>Prolog does not provide for a function type therefore, functions must
be defined as relations. That is, both the arguments to the function and
the result of the function must be parameters to the relation. This means
that composition of two functions cannot be constructed. As an example,
here is the factorial function defined as relation in Prolog. Note that
the definition requires two rules, one for the base case and one for the
inductive case. </P>

<BLOCKQUOTE>
<PRE>fac(0,1).
fac(N,F) :- N &gt; 0, M is N - 1,
       fac(M,Fm), F is N * Fm.
</PRE>
</BLOCKQUOTE>

<P>The second rule states that if <TT>N</TT> &gt; 0, <TT>M = N - 1</TT>,
<TT>Fm</TT> is <TT>(N-1)!</TT>, and <TT>F = N * Fm</TT>, then <TT>F</TT>
is <TT>N!</TT>. Notice how `<TT>is</TT>' is used. In this example it resembles
an assignment operator however, it may not be used to reassign a variable
to a new value. I the logical sense, the order of the clauses in the body
of a rule are irrelevant however, the order may matter in a practical sense.
<TT>M</TT> must not be a variable in the recursive call otherwise an infinite
loop will result. Much of the clumsiness of this definition comes from
the fact that <TT>fac</TT> is defined as a relation and thus it cannot
be used in an expression. Relations are commonly defined using multiple
rules and the order of the rules may determine the result. In this case
the rule order is irrelevant since, for each value of <TT>N</TT> only one
rule is applicable. Here are the Prolog equivalent of the definitions of
the gcd function, Fibonacci function and ackerman's function. </P>

<BLOCKQUOTE>
<PRE>gcd(A,B,GCD) :- A = B, GCD = A.
gcd(A,B,GCD) :- A &lt; B, NB is B - A, gcd(A,NB,GCD).
gcd(A,B,GCD) :- A &gt; B, NA is A - B, gcd(NA,B,GCD).
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>fib(0,1).
fib(1,1).
fib(N,F) :- N &gt; 1, N1 is N - 1, N2 is N - 2,
    fib(N1,F1), fib(N2,F2), F is F1 + F2.
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>ack(0,N,A) :- A is N + 1.
ack(M1,0,A) :- M &gt; 0, M is M - 1, ack(M,1,A).
ack(M1,N1,A) :- M1 &gt; 0, N1 &gt; 0, M is M - 1, N is N - 1,
   ack(M1,N,A1), ack(M,A1,A).
</PRE>
</BLOCKQUOTE>

<P>Notice that the definition of ackerman's function is clumsier than the
corresponding functional definition since the functional composition is
not available. Logic programming definition of the factorial function.
</P>

<BLOCKQUOTE>
<PRE>% factorial(N,F) &lt;- F is N!

factorial(0,s(0)).
factorial(s(N),F) :- factorial(N,F1), times(s(N),F1,F).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of factorial function. </P>

<BLOCKQUOTE>
<PRE>factorial(0,1).
factorial(N,F) :- N1 is N-1, factorial(N1,F1), F is N*F1.
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of the minimum. </P>

<BLOCKQUOTE>
<PRE>% minimum(M,N,Min) &lt;- Min is the minimum of {M, N}

minimum(M,N,M) :- less_than_or_equal(M,N).
minimum(M,N,N) :- less_than_or_equal(N,M).
</PRE>
</BLOCKQUOTE>

<P>Prolog programming definition of the minimum. </P>

<BLOCKQUOTE>
<PRE>minimum(M,N,M) :- M =&lt; N.
minimum(M,N,N) :- N =&lt; M.
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of the modulus. </P>

<BLOCKQUOTE>
<PRE>% mod(M,N,Mod) &lt;- Mod is the remainder of the integer division of M by N.

mod(X,Y,Z) :- less_than(Z,Y), times(Y,Q,W), plus(W,Z,X).

% or
mod(X,Y,X) :- less_than(X,Y).
mod(X,Y,X) :- plus(X1,Y,X), mod(X1,Y,Z).
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of Ackermann's function. </P>

<BLOCKQUOTE>
<PRE>ack(0,N,s(N)).
ack(s(M),0,Val) :- ack(M,s(0),Val).
ack(s(M),s(N),Val) :- ack(s(M),N,Val1), ack(M,Val1,Val).
</PRE>
</BLOCKQUOTE>

<P>Prolog definition of Ackermann's function. </P>

<BLOCKQUOTE>
<PRE>ack(0,N,Val) :- Val is N + 1.
ack(M,0,Val) :- M &gt; 0, M1 is M-1, ack(M1,1,Val).
ack(M,N,Val) :- M &gt; 0, N &gt; 0, M1 is M-1, N1 is N-1, 
                ack(M,N1,Val1), ack(M1,Val1,Val).
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of the Euclidian algorithm. </P>

<BLOCKQUOTE>
<PRE>gcd(X,0,X) :- X &gt; 0.
gcd(X,Y,Gcd) :- mod(X,Y,Z), gcd(Y,Z,Gcd).
</PRE>
</BLOCKQUOTE>

<P>Logic programming definition of the Euclidian algorithm. </P>

<BLOCKQUOTE>
<PRE>gcd(X,0,X) :- X &gt; 0.
gcd(X,Y,Gcd) :- mod(X,Y,Z), gcd(Y,Z,Gcd).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="list"></A>Lists</H2>

<DL>
<DT>Objective</DT>

<DT>Outline </DT>

<UL>
<LI>Lists </LI>

<LI>Composition of Recursive Programs </LI>

<LI>Iteration </LI>
</UL>
</DL>

<P>Lists are the basic data structure used in logic (and functional) programming.
Lists are a recursive data structure so recursion occurs naturally in the
definitions of various list operations. When defining operations on recursive
data structures, the definition most often naturally follows the recursive
definition of the data structure. In the case of lists, the empty list
is the base case. So operations on lists must consider the empty list as
a case. The other cases involve a list which is composed of an element
and a list. </P>

<P>Here is a recursive definition of the list data structure as found in
Prolog. </P>

<BLOCKQUOTE>
<PRE>List --&gt; [ ]
List --&gt; [Element|List]
</PRE>
</BLOCKQUOTE>

<P>Here are some examples of list representation, the first is the empty
list. </P>

<BLOCKQUOTE>
<PRE>Pair Syntax                Element Syntax
 [ ]             [ ] 
 [a|[ ]]         [a] 
 [a|b|[ ]]       [a,b] 
 [a|X]           [a|X] 
 [a|b|X]         [a,b|X] 
</PRE>
</BLOCKQUOTE>

<P>Predicates on lists are often written using multiple rules. One rule
for the empty list (the base case) and a second rule for non empty lists.
For example, here is the definition of the predicate for the length of
a list. </P>

<BLOCKQUOTE>
<PRE>% length(List,Number) &lt;- Number is lenght of List

length([],0).
length([H|T],N) :- length(T,M), N is M+1.
</PRE>
</BLOCKQUOTE>

<P>Element of a list. </P>

<BLOCKQUOTE>
<PRE>% member(Element,List) &lt;- Element is an element of the list List

member(X,[X|List).
member(X,[Element|List]) :- member(X,List).
</PRE>
</BLOCKQUOTE>

<P>Prefix of a list. </P>

<BLOCKQUOTE>
<PRE>% prefix(Prefix,List) &lt;- Prefix is a prefix of list List

prefix([],List).
prefix([X|Prefix],[X|List]) :- prefix(Prefix,List).
</PRE>
</BLOCKQUOTE>

<P>Suffix of a list. </P>

<BLOCKQUOTE>
<PRE>% suffix(Suffix,List) &lt;- Suffix is a suffix of list List

suffix(Suffix,Suffix).
prefix(Suffix,[X|List]) :- suffix(Suffix,List).
</PRE>
</BLOCKQUOTE>

<P>Append (concatenate) two lists. </P>

<BLOCKQUOTE>
<PRE>% append(List1,List2,List1List2) &lt;- 
%   List1List2 is the result of concatenating List1 and List2.

append([],List,List).
append([Element|List1],List2,[Element|List1List2]) :- 
append(List1,List2,List1List2).
</PRE>
</BLOCKQUOTE>

<P>Compare this code with the code for plus. sublist -- define using </P>

<UL>
<LI>Suffix of a prefix </LI>

<LI>Prefix of a suffix </LI>

<LI>Recursive definition of sublist using prefix </LI>

<LI>Suffix of a prefix using append </LI>

<LI>Prefix of a suffix using append </LI>
</UL>

<P>member, prefix and suffix -- defined using append reverse, delete, select,
sort, permutation, ordered, insert, quicksort. </P>

<H3>Iteration</H3>

<P>Iterative version of Length </P>

<BLOCKQUOTE>
<PRE>% length(List,Number) &lt;- Number is lenght of List
% Iterative version.

length(List,LenghtofList) :- length(List,0,LengthofList).

% length(SufixList,LengthofPrefix,LengthofList) &lt;- 
%         LengthofList is LengthofPrefix + length of SufixList

length([],LenghtofPrefix,LengthofPrefix).
length([Element|List],LengthofPrefix,LengthofList) :- 
PrefixPlus1 is LengthofPrefix + 1, 
length(List,PrefixPlus1,LengthofList).
</PRE>
</BLOCKQUOTE>

<P>Iterative version of Reverse </P>

<BLOCKQUOTE>
<PRE>% reverse(List,ReversedList) &lt;- ReversedList is List reversed.
% Iterative version.

reverse(List,RList) :- reverse(List,[],RList).

% length(SufixList,LengthofPrefix,LengthofList) &lt;- 
%         LengthofList is LengthofPrefix + length of SufixList

reverse([],RL,RL).
reverse([Element|List],RevPrefix,RL) :- 
reverse(List,[Element|RevPrefix],RL).
</PRE>
</BLOCKQUOTE>

<P>Here are some simple examples of common list operations defined by pattern
matching. The first sums the elements of a list and the second forms the
product of the elements of a list. </P>

<BLOCKQUOTE>
<PRE>sum([ ],0).
sum([X|L],Sum) :- sum(L,SL), Sum is X + SL.

product([ ],1).
product([X|L],Prod) :- product(L,PL), Prod is X * PL.
</PRE>
</BLOCKQUOTE>

<P>Another example common list operation is that of appending or the concatenation
of two lists to form a third list. Append may be described as the relation
between three lists, L1, L2, L3, where L1 = [x<SUB>1</SUB>,...,x<SUB>m</SUB>],
L2 = [y<SUB>1</SUB>,...,y<SUB>n</SUB>] and L3 = [x<SUB>1</SUB>,...,x<SUB>m</SUB>,y<SUB>1</SUB>,...,y<SUB>n</SUB>].
In Prolog, an inductive style definition is required. </P>

<BLOCKQUOTE>
<PRE>append([ ],L,L). 
append([X1|L1],L2, [X1|L3]) :- append(L1,L2,L3).
</PRE>
</BLOCKQUOTE>

<P>The first rule is the base case. The second rule is the inductive case.
In effect the second rule says that </P>

<BLOCKQUOTE>
<PRE>if L1 = [x<SUB>2</SUB>,...,x<SUB>m</SUB>],
      L2 = [y<SUB>1</SUB>,...,y<SUB>n</SUB>] and 
      L3 = [x<SUB>2</SUB>,...,x<SUB>m</SUB>,y<SUB>1</SUB>,...,y<SUB>n</SUB>],
then [x<SUB>1</SUB>,x<SUB>2</SUB>,...,x<SUB>m</SUB>,y<SUB>1</SUB>,...,y<SUB>n</SUB>], is the result of
appending  [x<SUB>1</SUB>,x<SUB>2</SUB>,...,x<SUB>m</SUB>] and L2.
</PRE>
</BLOCKQUOTE>

<P>The append relation is quite flexible. It can be used to determine if
an object is an element of a list, if a list is a prefix of a list and
if a list is a suffix of a list. </P>

<BLOCKQUOTE>
<PRE>member(X,L) :- append(_,[X|_],L).
prefix(Pre,L) :- append(Prefix,_,L).
suffix(L,Suf) :- append(_,Suf,L).
</PRE>
</BLOCKQUOTE>

<P>The underscore (_+) in the definitions denotes an anonymous variable
(or don`t care) whose value in immaterial to the definition. The member
relation can be used to derive other useful relations. </P>

<BLOCKQUOTE>
<PRE>vowel(X) :- member(X,[a,e,i,o,u]).
digit(D) :- member(D,['0','1','2','3','4','5','6','7','8','9']).
</PRE>
</BLOCKQUOTE>

<P>A predicate defining a list and its reversal can be defined using pattern
matching and the append relation as follows. </P>

<BLOCKQUOTE>
<PRE>reverse([ ],[ ]).
reverse([X|L],Rev) :- reverse(L,RL), append(RL,[X],Rev).
</PRE>
</BLOCKQUOTE>

<P>Here is a more efficient (iterative/tail recursive) version. </P>

<BLOCKQUOTE>
<PRE>reverse([ ],[ ]).
reverse(L,RL) :- reverse(L,[ ],RL).

reverse([ ],RL,RL).
reverse([X|L],PRL,RL) :- reverse(L,[X|PRL],RL).
</PRE>
</BLOCKQUOTE>

<P>To conclude this section, here is a definition of insertion sort. </P>

<BLOCKQUOTE>
<PRE>isort([ ],[ ]).
isort([X|UnSorted],AllSorted) :- isort(UnSorted,Sorted),
                                 insert(X,Sorted,AllSorted).

insert(X,[ ],[X]).
insert(X,[Y|L],[X,Y|L]) :- X =&lt; Y.
insert(X,[Y|L],[Y|IL]) :-  X &gt; Y, insert(X,L,IL).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="iteration"></A>Iteration</H2>

<P>Recursion is the only iterative method available in Prolog. However,
tail recursion can often be implemented as iteration. The following definition
of the factorial function is an `iterative' definition because it is `tail
recursive.' It corresponds to an implementation using a while-loop in an
imperative programming language. </P>

<BLOCKQUOTE>
<PRE>fac(0,1).
fac(N,F) :- N &gt; 0, fac(N,1,F).

fac(1,F,F).
fac(N,PP,F) :- N &gt; 1, NPp is N*PP, M is N-1, 
       fac(M,NPp,F). 
</PRE>
</BLOCKQUOTE>

<P>Note that the second argument functions as an <I>accumulator</I>. The
accumulator is used to store the partial product much as might be done
is a procedural language. For example, in Pascal an iterative factorial
function might be written as follows. </P>

<BLOCKQUOTE>
<PRE>function fac(N:integer) : integer;
var i : integer;
begin
   if N &gt;= 0 then begin
       fac := 1
      for I := 1 to N do
           fac := fac * I
   end
end;
</PRE>
</BLOCKQUOTE>

<P>In the Pascal solution <TT>fac</TT> acts as an accumulator to store
the partial product. The Prolog solution also illustrates the fact that
Prolog permits different relations to be defined by the same name provided
the number of arguments is different. In this example the relations are
fac/2 and fac/3 where fac is the ``functor&quot; and the number refers
to the arity of the predicate. As an additional example of the use of accumulators,
here is an iterative (tail recursive version) of the Fibonacci function.
</P>

<BLOCKQUOTE>
<PRE>fib(0,1).
fib(1,1).
fib(N,F) :- N &gt; 1, fib(N,1,1,F)

fib(2,F1,F2,F) :- F is F1 + F2.
fib(N,F1,F2,F) :- N &gt; 2, N1 is N - 1, NF1 is F1 + F2,
    fib(N1,NF1,F1,F).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="itgenback"></A>Iterators, Generators and Backtracking</H2>

<P>The following fact and rule can be used to generate the natural numbers.
% Natural Numbers </P>

<BLOCKQUOTE>
<PRE>nat(0).
nat(N) :- nat(M), N is M + 1.
</PRE>
</BLOCKQUOTE>

<P>The successive numbers are generated by backtracking. For example, when
the following query is executed successive natural numbers are printed.
</P>

<BLOCKQUOTE>
<PRE>?- nat(N), write(N), nl, fail.
</PRE>
</BLOCKQUOTE>

<P>The first natural number is generated and printed, then <TT>fail</TT>
forces backtracking to occur and the second rule is used to generate the
successive natural numbers. The following code generates successive prefixes
of an infinite list beginning with N. </P>

<BLOCKQUOTE>
<PRE>natlist(N,[N]).
natlist(N,[N|L]) :- N1 is N+1, natlist(N1,L).
</PRE>
</BLOCKQUOTE>

<P>As a final example, here is the code for generating successive prefixes
of the list of prime numbers. </P>

<BLOCKQUOTE>
<PRE>primes(PL) :- natlist(2,L2), sieve(L2,PL).

sieve([ ],[ ]).
sieve([P|L],[P|IDL]) :- sieveP(P,L,PL), sieve(PL,IDL).

sieveP(P,[ ],[ ]). 
sieveP(P,[N|L],[N|IDL]) :- N mod P  &gt;  0, sieveP(P,L,IDL).
sieveP(P,[N|L],   IDL)  :- N mod P =:= 0, sieveP(P,L,IDL).
</PRE>
</BLOCKQUOTE>

<P>Occasionally, backtracking and multiple answers are annoying. Prolog
provides the cut symbol (!) to control backtracking. The following code
defines a predicate where the third argument is the maximum of the first
two. </P>

<BLOCKQUOTE>
<PRE>max(A,B,M) :- A &lt;  B, M = B.
max(A,B,M) :- A &gt;= B, M = A.
</PRE>
</BLOCKQUOTE>

<P>The code may be simplified by dropping the conditions on the second
rule. </P>

<BLOCKQUOTE>
<PRE>max(A,B,B) :- A &lt;  B.
max(A,B,A).
</PRE>
</BLOCKQUOTE>

<P>However, in the presence of backtracking, incorrect answers can result
as is shown here. </P>

<BLOCKQUOTE>
<PRE>?- max(3,4,M).

M = 4;

M = 3
</PRE>
</BLOCKQUOTE>

<P>To prevent backtracking to the second rule the cut symbol is inserted
into the first rule. </P>

<BLOCKQUOTE>
<PRE>max(A,B,B) :- A &lt; B.!.
max(A,B,A).
</PRE>
</BLOCKQUOTE>

<P>Now the erroneous answer will not be generated. A word of caution: cuts
are similar to gotos in that they tend to increase the complexity of the
code rather than to simplify it. In general the use of cuts should be avoided.
</P>

<H2><A NAME="tuples"></A>Tuples ( or Records)</H2>

<P>We illustrate the data type of tuples with the code for the abstract
data type of a binary search tree. The binary search tree is represented
as either <TT>nil</TT> for the empty tree or as the tuple <TT>btree(Item,L_Tree,R_Tree)</TT>.
Here is the Prolog code for the creation of an empty tree, insertion of
an element into the tree, and an in-order traversal of the tree. </P>

<BLOCKQUOTE>
<PRE>create_tree(niltree).

inserted_in_is(Item,niltree, btree(Item,niltree,niltree)).

inserted_in_is(Item,btree(ItemI,L_T,R_T),Result_Tree) :- 
    Item @&lt; ItemI,
    inserted_in_is(Item,L_Tree,Result_Tree).

inserted_in_is(Item,btree(ItemI,L_T,R_T),Result_Tree) :- 
    Item @&gt; ItemI,
    inserted_in_is(Item,R_Tree,Result_Tree).

inorder(niltree,[ ]).
inorder(btree(Item,L_T,R_T),Inorder) :- 
          inorder(L_T,Left),
          inorder(R_T,Right),
          append(Left,[Item|Right],Inorder).
</PRE>
</BLOCKQUOTE>

<P>The membership relation is a trivial modification of the insert relation.
Since Prolog access to the elements of a tuple are by pattern matching,
a variety of patterns can be employed to represent the tree. Here are some
alternatives. </P>

<BLOCKQUOTE>
<PRE>[Item,LeftTree,RightTree]
Item/LeftTree/RightTree
(Item,LeftTree,RightTree)
</PRE>
</BLOCKQUOTE>

<H2><A NAME="extralogical"></A>Extra-Logical Predicates</H2>

<DL>
<DT>Objective</DT>

<DT>Outline </DT>

<UL>
<LI>Input/Output </LI>

<LI>Assert/Retract </LI>

<LI>System Access </LI>
</UL>
</DL>

<P>The class of predicates in Prolog that lie outside the logic programming
model are called <I>extra-logical</I> predicates. These predicates achieve
a side effect in the course of being satisfied as a logical goal. There
are three types of extra-logical predicates, predicates for handling I/O,
predicates for manipulating the program, and predicates for accessing the
underlying operating system. </P>

<H3><A NAME="io"></A>Input/Output</H3>

<P>Most Prolog implementations provide the predicates <TT>read</TT> and
<TT>write</TT>. Both take one argument, <TT>read</TT> unifies its argument
with the next term (terminated with a period) on the standard input and
<TT>write</TT> prints its argument to the standard output. As an illustration
of input and output as well as a more extended example, here is the code
for a checkbook balancing program. The section beginning with the comment
``Prompts&quot; handles the I/0. </P>

<BLOCKQUOTE>
<PRE>% Check Book Balancing Program.
checkbook :- initialbalance(Balance),
   newbalance(Balance).

% Recursively compute new balances 
newbalance(OldBalance) :- transaction(Transaction),
   action(OldBalance,Transaction).

% If transaction amount is 0 then finished.
action(OldBalance,Transaction) :- Transaction = 0, 
   finalbalance(OldBalance). %
%
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>% If transaction amount is not 0 then compute new balance.
action(OldBalance,Transaction) :- Transaction \+= 0, 
   NewBalance is OldBalance + Transaction,
   newbalance(NewBalance).  

%</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>% Prompts 
initialbalance(Balance) :- write('Enter initial balance: \'),
   read(Balance).

transaction(Transaction) :- 
   write('Enter Transaction, '),
    write('- for withdrawal, 0 to terminate): '),
   read(Transaction).
finalbalance(Balance) :- write('Your final balance is: \'),
   write(Balance), nl.
</PRE>
</BLOCKQUOTE>

<DL>
<DT><B>Files</B> </DT>

<DT>see(File)</DT>

<DD>Current input file is now File. </DD>

<DT>seeing(File)</DT>

<DD>File is unified with the name of the current input file. </DD>

<DT>seen</DT>

<DD>Closes the current input file. </DD>

<DT>tell(File)</DT>

<DD>Current output file is now File. </DD>

<DT>telling(File)</DT>

<DD>File is unified with the name of the current output file. </DD>

<DT>told</DT>

<DD>Closes the current output file. </DD>

<DT><B>Term I/O</B></DT>

<DT>read(Term)</DT>

<DD>Reads next full-stop (period) delimited term from the current input
stream, if eof then returns the atom 'end_of_file'. </DD>

<DT>write(Term)</DT>

<DD>Writes a term to the current output stream. </DD>

<DT>print(Term)</DT>

<DD>Writes a term to the current output stream. Uses a user defined predicate
portray/1 to write the term, otherwise uses write. </DD>

<DT>writeq(Term)</DT>

<DD>Writes a term to the current output stream in a form aceptable as input
to read. </DD>

<DT><B>Character I/O</B> </DT>

<DT>get(N)</DT>

<DD>N is the ASCII code of the next non-blank printable character on the
current input stream. If end of file, then a -1 is returned. </DD>

<DT>put(N)</DT>

<DD>Puts the character corresponding to ASCII code N on the current output
stream. </DD>

<DT>nl</DT>

<DD>Causes the next output to be on a new line. </DD>

<DT>tab(N)</DT>

<DD>N spaces are output to the current output stream. </DD>

<DT><B>Program Access</B> </DT>

<DT>consult(SourceFile)</DT>

<DD>Loads SourceFile into the interpreter but, if a predicate is defined
accross two or more files, consulting them will result in only the clauses
in the file last consulted being used. </DD>

<DT>reconsult(File)</DT>

<DD>available in some systems. </DD>

<DT><B>Other</B> </DT>

<DT>name(Atom,ASCII_List)</DT>

<DD>the conversion routine between lists of ASCII codes and atoms. </DD>
</DL>

<P>display, prompt </P>

<BLOCKQUOTE>
<PRE>% Read a sentence and return a list of words.

read_in([W|Ws]) :- get0(C), read_word(C,W,C1), rest_sent(W,C1,Ws).

% Given a word and the next character, read in the rest of the sentence

rest_sent(W,_,[]) :- lastword(W).
rest_sent(W,C,[W1|Ws]) :- read_word(C,W1,C1), rest_sent(W1,C1,Ws).

read_word(C,W,C1) :- single_character(C),!,name(W,[C]), get0(C1).
read_word(C,W,C2) :- in_word(C,NewC), get0(C1),
                    rest_word(C1,Cs,C2), name(W,[NewC|Cs]).
read_word(C,W,C2) :- get0(C1), read_word(C1,W,C2).

rest_word(C,[NewC|Cs],C2) :- in_word(C,NewC), !, get0(C1), 
rest_word(C1,Cs,C2).
rest_word(C,[],C).

% These are single character words.

single_character(33).      % !
single_character(44).      % ,
single_character(46).      % .
single_character(58).      % :
single_character(59).      % ;
single_character(63).      % ?

% These characters can appear within a word.

in_word(C,C) :- C &gt; 96, C &lt; 123.               % a,b,...,z
in_word(C,L) :- C &gt; 64, C &lt; 91, L is C + 32.   % A,B,...,Z
in_word(C,C) :- C &gt; 47, C &lt; 58.                % 0,1,...,9
in_word(39,39).                                % '
in_word(45,45).                                % -

% These words terminate a sentence.

lastword('.').
lastword('!').
lastword('?').
</PRE>
</BLOCKQUOTE>

<H3>Program Access and Manipulation</H3>

<DL>
<DT>clause(Head,Body)</DT>

<DT>assert(Clause)</DT>

<DD>adds clause to the end of the database </DD>

<DT>asserta(Clause)</DT>

<DT>retract(Clause_Head)</DT>

<DT>consult(File_Name)</DT>
</DL>

<H3>System Access</H3>

<DL>
<DT>system(Command)</DT>

<DD>Execute Command in the operating system </DD>
</DL>

<H2><A NAME="style"></A>Style and Layout</H2>

<DL>
<DT>Objective </DT>

<DT>Outline </DT>

<UL>
<LI>Style and Layout </LI>

<LI>Debugging </LI>
</UL>
</DL>

<P>Some conventions for comments. </P>

<UL>
<LI>Long comments should precede the code they refer to while short comments
should be interspersed with the code itself. </LI>

<LI>Program comments should describe what the program does, how it is used
(goal predicate and expected results), limitations, system dependent features,
performance, and examples of using the program. </LI>

<LI>Predicate comments explain the purpose of the predicate, the meaning
and relationship among the arguments, and any restrictions as to argument
type. </LI>

<LI>Clause comments add to the description of the case the particular clause
deals with and is usefull for documenting cuts. </LI>
</UL>

<P>Some conventions for program layout </P>

<UL>
<LI>Group clauses belonging to a relation or ADT together. </LI>

<LI>Clauses should be short. Their body should contain no more than a few
goals. </LI>

<LI>Make use of indentation to improve the readability of the body of a
clause. </LI>

<LI>Mnemonic names for relations and variables should be used. Names should
indicate the meaning of relations and the role of data objects. </LI>

<LI>Clearly separate the clauses defining different relations. </LI>

<LI>The cut operator should be used with care. The use of `red' cuts should
be limited to clearly defined mutually exclusive alternatives. </LI>
</UL>

<P>Illustration </P>

<BLOCKQUOTE>
<PRE>merge( List1, List2, List3 ) :-
 ( List1 = [], !, List3 = List2 );
 ( List2 = [], !, List3 = List1 );
 ( List1 = [X|L1], List2 = [Y|L2 ),
((X &lt; Y, ! Z = X, merge( L1, List2, L3 ) );
( Z = Y, merge( List1, L2, L3 ) )),
  List3 = [Z|L3].
</PRE>
</BLOCKQUOTE>

<P>A better version </P>

<BLOCKQUOTE>
<PRE>merge( [], List2, List2 ). 
merge( List1, [], List1 ). 

merge( [X|List1], [Y|List2], [X|List3] ) :-
X &lt; Y, !,  merge( List1, List2, List3 ).  \% Red Cut
merge( List1, [Y|List2], [Y|List3] ) :-
 merge( List1, List2, List3 ).
</PRE>
</BLOCKQUOTE>

<H3>Debugging</H3>

<P>trace/notrace, spy/nospy, programmer inserted debugging aids -- write
predicates and p :- write, fail. </P>

<H2><A NAME="negation"></A>Negation and Cuts</H2>

<DL>
<DT>Objective</DT>

<DT>Outline </DT>

<UL>
<LI>Negation as failure </LI>

<LI>Green Cuts </LI>

<LI>Red Cuts </LI>
</UL>
</DL>

<H3>Negation</H3>

<H3>Cuts</H3>

<H4>Green cuts: Determinism</H4>

<P>Selection among mutually exclusive clauses. </P>

<H4>Tail Recursion Optimization</H4>

<P>Prevention of backtracking when only one solution exists. </P>

<BLOCKQUOTE>
<PRE>A :- B1,...,Bn,Bn1.
A :- B1,...,Bn,!,Bn1. % prevents backtracking
</PRE>
</BLOCKQUOTE>

<H4>Red cuts: omitting explicit conditions</H4>

<H2><A NAME="dcg"></A>Definite Clause Grammars</H2>

<DL>
<DT>Objective:</DT>

<DT>Outline</DT>

<UL>
<LI>The parsing problem: Context-free grammars; Construct a parse tree
for a sentence given the context-free grammar. </LI>

<LI>Representing the Parsing Problem in Prolog </LI>

<LI>The Grammar Rule Notation] (Definite Clause Grammars -- DCG) </LI>

<LI>Adding Extra Arguments </LI>

<LI>Adding Extra Tests </LI>
</UL>
</DL>

<P>Prolog originated from attempts to use logic to express grammar rules
and formalize the parsing process. Prolog has special syntax rules which
are called <I>definite clause grammars</I> (DCG). DCGs are a generalization
of context free grammars. </P>

<H3>Context Free Grammars</H3>

<P>A context free grammar is a set of rules of the form: </P>

<BLOCKQUOTE>
<PRE><nonterminal> -&gt; 
</PRE>
</BLOCKQUOTE>

<P>where <TT>nonterminal</TT> is a nonterminal and <TT>body</TT> is a sequence
of one or more items. Each item is either a nonterminal symbol or a sequence
of terminal symbols. The meaning of the rule is that the <TT>body</TT>
is a possible form for an object of type <TT>nonterminal</TT>. </P>

<BLOCKQUOTE>
<PRE>S --&gt; a b
S --&gt; a S b
</PRE>
</BLOCKQUOTE>

<H3>DCG</H3>

<P>Nonterminals are written as Prolog atoms, the items in the body are
separated with commas and sequences of terminal symbols are written as
lists of atoms. For each nonterminal symbol, S, a grammar defines a language
which is obtained by repeated nondeterministic application of the grammar
rules, starting from S. </P>

<BLOCKQUOTE>
<PRE>s --&gt; [a],[b].
s --&gt; [a],s,[b].
</PRE>
</BLOCKQUOTE>

<P>As an illustration of how DCG are used, the string [a,a,b,b] is given
to the grammar to be parsed. </P>

<BLOCKQUOTE>
<PRE>?- s([a,a,b,b],[]).  
   yes
</PRE>
</BLOCKQUOTE>

<P>Here is a natural language example. </P>

<BLOCKQUOTE>
<PRE>% DCGrammar

sentence --&gt; noun_phrase, verb_phrase.

noun_phrase --&gt; determiner, noun.
noun_phrase --&gt; noun.

verb_phrase --&gt; verb.
verb_phrase --&gt; verb, noun_phrase.

% Vocabulary

determiner --&gt; [the].
determiner --&gt; [a].

noun --&gt; [cat].
noun --&gt; [cats].
noun --&gt; [mouse].
noun --&gt; [mice].

verb --&gt; [scare].
verb --&gt; [scares].
verb --&gt; [hate].
verb --&gt; [hates].
</PRE>
</BLOCKQUOTE>

<P>Context free grammars cannot define the required agreement in number
between the noun phrase and the verb phrase. That information is context
dependent (sensitive). However, DCG are more general Number agreement </P>

<BLOCKQUOTE>
<PRE>% DCGrammar - with number agreement between noun phrase and verb phrase

sentence --&gt; noun_phrase(Number), verb_phrase(Number).

noun_phrase(Number) --&gt; determiner(Number), noun(Number).
noun_phrase(Number) --&gt; noun(Number).

verb_phrase(Number) --&gt; verb(Number).
verb_phrase(Number) --&gt; verb(Number), noun_phrase(Number1).

% Vocabulary

determiner(Number) --&gt; [the].
determiner(singular) --&gt; [a].

noun(singular) --&gt; [cat].
noun(plural) --&gt; [cats].
noun(singular) --&gt; [mouse].
noun(plural) --&gt; [mice].

verb(plural) --&gt; [scare].
verb(singular) --&gt; [scares].
verb(plural) --&gt; [hate].
verb(singular) --&gt; [hates].
</PRE>
</BLOCKQUOTE>

<H3>Parse Trees</H3>

<BLOCKQUOTE>
<PRE>% DCGrammar -- with parse tree as a result

sentence(sentence(NP,VP)) --&gt; noun_phrase(NP), verb_phrase(VP).

noun_phrase(noun_phrase(D,NP)) --&gt; determiner(D), noun(NP).
noun_phrase(NP) --&gt; noun(NP).

verb_phrase(verb_phrase(V)) --&gt; verb(V).
verb_phrase(verb_phrase(V,NP)) --&gt; verb(V), noun_phrase(NP).

% Vocabulary

determiner(determiner(the)) --&gt; [the].
determiner(determiner(a)) --&gt; [a].

noun(noun(cat)) --&gt; [cat].
noun(noun(cats)) --&gt; [cats].
noun(noun(mouse)) --&gt; [mouse].
noun(noun(mice)) --&gt; [mice].

verb(verb(scare)) --&gt; [scare].
verb(verb(scares)) --&gt; [scares].
verb(verb(hate)) --&gt; [hate].
verb(verb(hates)) --&gt; [hates].
</PRE>
</BLOCKQUOTE>

<H3>Simple Semantics for Natural Language Sentences</H3>

<H4>Transitive and intransitive verbs</H4>

<BLOCKQUOTE>
<PRE>% DCGrammar -- Transitive and intransitive verbs

sentence(VP) --&gt; noun_phrase(Actor), verb_phrase(Actor,VP).

noun_phrase(Actor) --&gt; proper_noun(Actor).

verb_phrase(Actor,VP) --&gt; intrans_verb(Actor,VP).
verb_phrase(Actor,VP) --&gt; transitive_verb(Actor,Something,VP),
                             noun_phrase(Something).

% Vocabulary

proper_noun(john)  --&gt; [john].
proper_noun(annie) --&gt; [annie].

intrans_verb(Actor,paints(Actor))  --&gt; [paints].

transitive_verb(Somebody,Something,likes(Somebody,Something)) --&gt; [likes].
</PRE>
</BLOCKQUOTE>

<H4>Determiners -- `a' and `every'</H4>

<BLOCKQUOTE>
<PRE>:- op( 100, xfy, and).
:- op( 150, xfy, =&gt;).


% DCGrammar -- Transitive and intransitive verbs

sentence(S) --&gt; noun_phrase(X,Assn,S), verb_phrase(X,Assn).

noun_phrase(X,Assn,S) --&gt; determiner(X,Prop,Assn,S), noun(X,Prop).

verb_phrase(X,Assn) --&gt; intrans_verb(X,Assn).

% Vocabulary

determiner(X,Prop,Assn,exists(X,Prop and Assn)) --&gt; [a].
determiner(X,Prop,Assn,    all(X,Prop =&gt; Assn)) --&gt; [every].

noun(X,man(X))  --&gt; [man].
noun(X,woman(X))  --&gt; [woman].

intrans_verb(X,paints(X))  --&gt; [paints].
intrans_verb(X,dances(X))  --&gt; [dances].

</PRE>
</BLOCKQUOTE>

<H4>Relative Clauses</H4>

<H3>Interleaving syntax and semantics in DCG</H3>

<BLOCKQUOTE>
<PRE>% Word level
sentence --&gt; word(W), rest_sent(W).

rest_sent(W) --&gt; {last_word(W)}.
rest_sent(_) --&gt; word(W), rest_sent(W).

% Character level
word(W) --&gt; {single_char_word(W)},   [W].
word(W) --&gt; {multiple_char_word(W)}, [W].
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>% Read a sentence and return a list of words.

sentence --&gt; {get0(C)}, word(C,W,C1), rest_sent(C1,W).

% Given the next character and the previous word,
% read the rest of the sentence

rest_sent(C,W) --&gt; {lastword(W)}.                  % empty
rest_sent(C,_) --&gt; word(C,W,C1), rest_sent(C1,W).

word(C,W,C1) --&gt; {single_character(C),!,name(W,[C]), get0(C1)}, [W].  % !,.:;?
word(C,W,C2) --&gt; {in_word(C,Cp), get0(C1), rest_word(C1,Cs,C2),
                     name(W,[Cp|Cs])},[W].                         
word(C,W,C2) --&gt; {get0(C1)}, word(C1,W,C2).                   % consume blanks

% These words terminate a sentence.

lastword('.').
lastword('!').
lastword('?').

% This reads the rest of the word plus the next character.

rest_word(C,[Cp|Cs],C2) :- in_word(C,Cp), get0(C1), rest_word(C1,Cs,C2).
rest_word(C,[],C).

% These are single character words.

single_character(33).      % !
single_character(44).      % ,
single_character(46).      % .
single_character(58).      % :
single_character(59).      % ;
single_character(63).      % ?

% These characters can appear within a word.

in_word(C,C) :- C &gt; 96, C &lt; 123.               % a,b,...,z
in_word(C,L) :- C &gt; 64, C &lt; 91, L is C + 32.   % A,B,...,Z
in_word(C,C) :- C &gt; 47, C &lt; 58.                % 0,1,...,9
in_word(39,39).                                % '
in_word(45,45).                                % -
</PRE>
</BLOCKQUOTE>

<P>a calculator!! </P>

<H2><A NAME="inc"></A>Incomplete Data Structures</H2>

<DL>
<DT>Objective</DT>

<DT>Outline </DT>

<UL>
<LI>Difference Lists </LI>

<LI>Dictionaries </LI>

<LI>Queue </LI>

<LI>QuickSort </LI>
</UL>
</DL>

<P>An incomplete data structure is a data structure containing a variable.
Such a data structure is said to be `partially instantiated' or `incomplete.'
We illustrate the programming with incomplete data structures by modifying
the code for a binary search tree. The resulting code permits the relation
<TT>inserted_in_is</TT> to define both the insertion and membership relations.
The empty tree is represented as a variable while a partially instantiated
tree is represented as a tuple. </P>

<BLOCKQUOTE>
<PRE>create_tree(Niltree) :- var(Niltree). % Note: Nil is a variable

inserted_in_is(Item,btree(Item,L_T,R_T)).
     
inserted_in_is(Item,btree(ItemI,L_T,R_T)) :- 
    Item @&lt; ItemI,
    inserted_in_is(Item,L_T).

inserted_in_is(Item, btree(ItemI,L_T,R_T)) :- 
    Item @&gt; ItemI,
    inserted_in_is(Item,R_T).

inorder(Niltree,[ ]) :- var(Niltree).
inorder(btree(Item,L_T,R_T),Inorder) :- 
          inorder(L_T,Left),
          inorder(R_T,Right),
          append(Left,[Item|Right],Inorder).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="meta"></A>Meta Level Programming</H2>

<P>Meta-programs treat other programs as data. They analyze, transform,
and simulate other programs. Prolog clauses may be passed as arguments,
added and deleted from the Prolog data base, and may be constructed and
then executed by a Prolog program. Implementations may require that the
functor and arity of the clause be previously declared to be a dynamic
type. </P>

<DL>
<DT>Objective</DT>

<DT>Outline </DT>

<UL>
<LI>Meta-logical Type Predicates </LI>

<LI>Assert/Retract </LI>

<LI>System Access </LI>
</UL>
</DL>

<H3>Meta-Logical Type Predicates</H3>

<DL>
<DT>var(V)</DT>

<DD>Tests whether V is a variable. </DD>

<DT>nonvar(NV)</DT>

<DD>Tests whether NV is a non-variable term. </DD>

<DT>atom(A)</DT>

<DD>Tests whether A is an atom (non-variable term of arity 0 other than
a number). </DD>

<DT>integer(I)</DT>

<DD>Tests whether I is an integer. </DD>

<DT>number(N)</DT>

<DD>Tests whether N is a number. </DD>
</DL>

<H3>Term Comparison</H3>

<DL>
<DT>X = Y</DT>

<DT>X == Y</DT>

<DT>X =:= Y</DT>
</DL>

<H3>The Meta-Variable Facility</H3>

<DL>
<DT>call(X)</DT>

<DD>this </DD>
</DL>

<H3>Assert/Retract</H3>

<P>Here is an example illustrating how clauses may be added and deleted
from the Prolog data base. The example shows how to simulate an assignment
statement by using <TT>assert</TT> and <TT>retract</TT> to modify the association
between a variable and a value. </P>

<BLOCKQUOTE>
<PRE>:- dynamic x/1 .% this may be required in some Prologs  

x(0).  % An initial value is required in this example

assign(X,V) :- Old =..[X,_], retract(Old),
                  New =..[X,V], assert(New).
</PRE>
</BLOCKQUOTE>

<P>Here is an example using the assign predicate. </P>

<BLOCKQUOTE>
<PRE>?- x(N).

N = 0
yes
?- assign(x,5).
yes
?- x(N).

N = 5
</PRE>
</BLOCKQUOTE>

<P>Here are three programs illustrating Prolog's meta programming capability.
This first program is a simple interpreter for pure Prolog programs. </P>

<BLOCKQUOTE>
<PRE>% Meta Interpreter for pure Prolog

prove(true).
prove((A,B)) :- prove(A), prove(B).
prove(A) :- clause(A,B), prove(B).
</PRE>
</BLOCKQUOTE>

<P>Here is an execution of an append using the interpreter. </P>

<BLOCKQUOTE>
<PRE> ?- prove(append([a,b,c],[d,e],F)).

F = [a,b,c,d,e]
</PRE>
</BLOCKQUOTE>

<P>It is no different from what we get from using the usual run time system.
The second program is a modification of the interpreter, in addition to
interpreting pure Prolog programs it returns the sequence of deductions
required to satisfy the query. </P>

<BLOCKQUOTE>
<PRE>% Proofs for pure Prolog programs

proof(true,true).
proof((A,B),(ProofA,ProofB)) :- proof(A,ProofA), proof(B,ProofB).
proof(A,(A:-Proof)) :- clause(A,B), proof(B,Proof).
</PRE>
</BLOCKQUOTE>

<P>Here is a proof an append. </P>

<BLOCKQUOTE>
<PRE>?- proof(append([a,b,c],[d,e],F),Proof).

F = [a,b,c,d,e]
Proof = (append([a,b,c],[d,e],[a,b,c,d,e]) :-
           (append([b,c],[d,e],[b,c,d,e]) :-
           (append([c],[d,e],[c,d,e]) :- 
           (append([ ],[d,e],[d,e]) :- true))))
</PRE>
</BLOCKQUOTE>

<P>The third program is also a modification of the interpreter. In addition
to interpreting pure Prolog programs, is a trace facility for pure Prolog
programs. It prints each goal twice, before and after satisfying the goal
so that the programmer can see the parameters before and after the satisfaction
of the goal. </P>

<BLOCKQUOTE>
<PRE>% Trace facility for pure Prolog

trace(true).
trace((A,B)) :- trace(A), trace(B).
trace(A) :- clause(A,B), downprint(A), trace(B), upprint(A).

downprint(G) :- write('&gt;'), write(G), nl.
upprint(G)   :- write('&lt;'), write(G), nl.
</PRE>
</BLOCKQUOTE>

<P>Here is a trace of an append. </P>

<BLOCKQUOTE>
<PRE>?- trace(append([a,b,c],[d,e],F)).
&gt;append([a,b,c],[d,e],[a|<SUB>1</SUB>427104])
&gt;append([b,c],[d,e],[b|<SUB>1</SUB>429384])
&gt;append([c],[d,e],[c|<SUB>1</SUB>431664])
&gt;append([ ],[d,e],[d,e])
&lt;append([ ],[d,e],[d,e])
&lt;append([c],[d,e],[c,d,e])
&lt;append([b,c],[d,e],[b,c,d,e])
&lt;append([a,b,c],[d,e],[a,b,c,d,e])

F = [a,b,c,d,e]
</PRE>
</BLOCKQUOTE>

<H4>Predictates for program manipulation</H4>

<UL>
<LI>consult(<I>file name</I>) </LI>

<LI>var(<I>term</I>), nonvar(<I>term</I>), atom(<I>term</I>), integer(<I>term</I>),
atomic(<I>term</I>) </LI>

<LI>functor(<I>Term</I>,<I>Functor</I>,<I>arity</I>), arg(<I>N</I>,<I>term</I>,<I>N-th
arg</I>), <I>Term</I> =..<I>List</I> </LI>

<LI>call(<I>Term</I>) </LI>

<LI>clause(<I>Head</I>,<I>Body</I>), assertz(<I>Clause</I>), retract(<I>Clause</I>)
</LI>
</UL>

<H2><A NAME="2ndOrder"></A>Second-Order Programming</H2>

<DL>
<DT>Objective:</DT>

<DD>Second-Order Programming </DD>

<DT>Outline: </DT>

<UL>
<LI>Setof, Bagof, Findall </LI>

<LI>Other second-order predicates </LI>

<LI>Applications </LI>
</UL>
</DL>

<H3>Setof, Bagof and Findall</H3>

<H3>Other second-order predicates</H3>

<P>has_property, map_list, filter, foldr etc </P>

<UL>
<LI>Variable predicate names </LI>

<BLOCKQUOTE>
<PRE>p(P,X,Y) :- P(X,Y).
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>p(P,X,Y) :- R =..[P,X,Y], call(R).
</PRE>
</BLOCKQUOTE>
</UL>

<P>For the following functions let S be the list [S_1,...,S_n]. </P>

<OL>
<LI>The function <TT>map</TT> where <TT>map(f,S)</TT> is [f(S_1),...,f(S_n)].
</LI>

<LI>The function <TT>filter</TT> where <TT>filter(P,S)</TT> is the list
of elements of S that satisfy the predicate P. </LI>

<LI>The function <TT>foldl</TT> where <TT>foldl(Op,In,S)</TT> which folds
up S, using the given binary operator Op and start value In, in a left
associative way, ie, foldl(op, r,[a,b,c]) = (((r op a) op b) op c). </LI>

<LI>The function <TT>foldr</TT> where <TT>foldr(Op,In,S)</TT> which folds
up S, using the given binary operator Op and start value In, in a right
associative way, ie, foldr(op,r,[a,b,c]) = a op (b op (c op r)). </LI>

<LI>The function <TT>map2</TT> is similar to <TT>map</TT>, but takes a
function of two arguments, and maps it along two argument lists. </LI>

<LI>The function <TT>scan</TT> where <TT>scan(op, r, S)</TT> applies <TT>foldl
op r)</TT> to every initial segment of a list. For example <TT>scan (+)
0 x)</TT> computes running sums. </LI>

<LI>The function <TT>dropwhile</TT> where <TT>dropwhile(P,S)</TT> which
returns the suffix of S where each element of the prefex satisfies the
predicate P. </LI>

<LI>The function <TT>takewhile</TT> where <TT>takewhile(P,S)</TT> returns
the list of initial element of S which satisfy P. </LI>

<LI>The function <TT>until</TT> where <TT>until(P,F,V)</TT> returns the
result of applying the function F to the value the smallest number of times
necessary to satisfy the predicate. Example until (&gt;1000) (2*) 1 = 1024
</LI>

<LI>The function <TT>iterate</TT> where <TT>iterate(f,x)</TT> returns the
infinite list [x, f x, f(f x), ... ] </LI>

<LI>Use the function <TT>foldr</TT> to define the functions, sum, product
and reverse. </LI>

<LI>Write a generic sort program, it should take a comparison function
as a parameter. </LI>

<LI>Write a generic transitive closer program, it should take a binary
relation as a parameter. </LI>
</OL>

<H3>Applications</H3>

<P>Generalized sort, transitive closure ... </P>

<BLOCKQUOTE>
<PRE>transitive_closure(Relation,Item1,Item2) :- Predicate =..[Relation,Item1,Item2],
                                            call(Predicate).
transitive_closure(Relation,Item1,Item2) :- Predicate =..[Relation,Item1,Link],
                                            call(Predicate),
transitive_closure(Relation,Link,Item2).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="database"></A>Database Programming</H2>

<DT>Objective:</DT>

<DD>Logic Programming as Database Programming </DD>

<DT>Outline </DT>

<UL>
<LI>Simple Family Database </LI>

<LI>Recursive Rules </LI>

<LI>Logic Programming and the Relational Database Model (relational algebra)
</LI>
</UL>

<H3>Simple Databases</H3>

<P>Basic predicates: <TT>father/2,mother/2, male/1, female/1</TT>. </P>

<BLOCKQUOTE>
<PRE>father(Father,Child).
mother(Mother,Child).
male(Person). 
female(Person).
son(Son,Parent).
daughter(Daughter,Parent).
parent(Parent,Child).
grandparent(Grandparent,Grandchild).
</PRE>
</BLOCKQUOTE>

<P>Question: Which should be facts and which should be rules? Example:
if parent, male and female are facts then father and mother could be rules.
</P>

<BLOCKQUOTE>
<PRE>father(Parent,Child) :- parent(Parent,Child), male(Parent).
mother(Parent,Child) :- parent(Parent,Child), female(Parent).
</PRE>
</BLOCKQUOTE>

<P>Some other relations that could be defined are. </P>

<BLOCKQUOTE>
<PRE>mother(Woman) :- mother(Woman,Child).
parents(Father,Mother) :- father(Father,Child), mother(Mother,Child).
brother(Brother,Sibling) :- parent(P,Brother), parent(P,Sibling),
    male(Brother), Brother  Sibling.
uncle(Uncle,Person) :- brother(Uncle,Parent), parent(Parent,Person).
sibling(Sib1,Sib2) :- parent(P,Sib1), parent(P,Sib2), Sib1 =\= Sib2.
cousin(Cousin1,Cousin2) :- parent(P1,Cousin1), parent(P2,Cousin2),
   sibling(P1,P2).
</PRE>
</BLOCKQUOTE>

<P>What about: sister, niece, full_ sibling, mother_in_law, etc. </P>

<H3>Recursive Rules</H3>

<BLOCKQUOTE>
<PRE>ancestor(Ancestor,Descendent) :- parent(Ancestor,Descendent).
ancestor(Ancestor,Descendent) :- parent(Ancestor,Person),
   ancestor(Persion,Descendent).
</PRE>
</BLOCKQUOTE>

<P>The <TT>ancestor</TT> relation is an example of the more general relation
of transitive closure. Here is an example of the transitive closure for
graphs. Transitive closure: connected </P>

<BLOCKQUOTE>
<PRE>edge(Node1,Node2).
...
connected(Node1,Node2) :- edge(Node1,Node2).
connected(Node1,Node2) :- edge(Node1,Link), connected(Link,Node2).
</PRE>
</BLOCKQUOTE>

<H3>Logic programs and the relational database model</H3>

<P>The mathematical concept underlying the relational database model is
the set-theoretic <I>relation</I>, which is a subset of the Cartesian product
of a list of domains. A domain is a set of values. A <I>relation</I> is
any subset of the Cartesian product of one or more domains. The members
of a relation are called <I>tuples</I>. In relational databases, a relation
is viewed as a table. The Prolog view of a relation is that of a set of
named tuples. For example, in Prolog form, here are some unexpected entries
in a city-state-population relation. </P>

<BLOCKQUOTE>
<PRE>city_state_population('San Diego','Texas',4490).
city_state_population('Miami','Oklahoma',13880).
city_state_population('Pittsburg','Iowa',509).
</PRE>
</BLOCKQUOTE>

<P>In addition to defining relations as a set of tuples, a relational database
management system (DBMS) permits new relations to be defined via a query
language. In Prolog form this means defining a rule. For example, the sub-relation
consisting of those entries where the population is less than 1000 can
be defined as follows: </P>

<BLOCKQUOTE>
<PRE>smalltown(Town,State,Pop) :- city_state_pop(Town,State,Pop), Pop &lt; 1000.
</PRE>
</BLOCKQUOTE>

<P>One of the query languages for relational databases is the Relational
Algebra. Its operations are union, set difference, Cartesian product, projection,
and selection. They may be defined for two relations r and s as follows.
</P>

<BLOCKQUOTE>
<PRE>% Union of relations r/n and s/n 
r_union_s(X1,...,Xn) :- r(X1,...,Xn).
r_union_s(X1,...,Xn) :- s(X1,...,Xn).

% Set Difference  r/n $\setminus$ s/n
r_diff_s(X1,...,Xn) :- r(X1,...,Xn), not s(X1,...,Xn).
r_diff_s(X1,...,Xn) :- s(X1,...,Xn), not r(X1,...,Xn).

% Cartesian product r/m, s/n
r_x_s(X1,...,Xm,Y1,...,Yn) :- r(X1,...,Xm), s(Y1,...,Yn).

% Projection
r_p_i_j(Xi,Xj) :- r(X1,...,Xn).

% Selection
r_c(X1,...,Xn) :- r(X1,...,Xn), c(X1,...,Xn).

% Meet
r_m_s(X1,...,Xn) :- r(X1,...,Xn), s(X1,...,Xn).

% Join
r_j_s(X'1,...,X'j,Y'1,...,Y'k) :- r(X1,...,Xn), s(Y1,...,Yn).
</PRE>
</BLOCKQUOTE>

<P>The difference between Prolog and a Relational DBMS is that the in Prolog
the relations are stored in main memory along with the program whereas
in a Relational DBMS the relations are stored in files and the program
extracts the information from the files. </P>

<H2><A NAME="expert"></A>Expert systems</H2>

<P>Expert systems may be programmed in one of two ways in Prolog. One is
to construct a knowledge base using Prolog facts and rules and use the
built-in inference engine to answer queries. The other is to build a more
powerful inference engine in Prolog and use it to implement an expert system.
</P>

<P>Pattern matching: Symbolic differentiation </P>

<TABLE>
<TR>
<TD>d(X,X,1)</TD>

<TD>:-</TD>

<TD>!.</TD>
</TR>

<TR>
<TD>d(C,X,0)</TD>

<TD>:-</TD>

<TD>atomic(C).</TD>
</TR>

<TR>
<TD>d(-U,X,-A)</TD>

<TD>:-</TD>

<TD>d(U,X,A).</TD>
</TR>

<TR>
<TD>d(U+V,X,A+B)</TD>

<TD>:-</TD>

<TD>d(U,X,A), d(V,X,B).</TD>
</TR>

<TR>
<TD>d(U-V,X,A-B)</TD>

<TD>:-</TD>

<TD>d(U,X,A), d(V,X,B).</TD>
</TR>

<TR>
<TD>d(C*U,X,C*A)</TD>

<TD>:-</TD>

<TD>atomic(C), CX, d(U,X,A),!.</TD>
</TR>

<TR>
<TD>d(U*V,X,B*U+A*V)</TD>

<TD>:-</TD>

<TD>d(U,X,A), D(V,X,B).</TD>
</TR>

<TR>
<TD>d(U/V,X,A)</TD>

<TD>:-</TD>

<TD>d(U*V^-1,X,A)</TD>
</TR>

<TR>
<TD>d(U^C,X,C*U^(C-1)*W)</TD>

<TD>:-</TD>

<TD>atomic(C), CX, d(U,X,W).</TD>
</TR>

<TR>
<TD>d(log(U),X,A*U^(-1))</TD>

<TD>:-</TD>

<TD>d(U,X,A).</TD>
</TR>
</TABLE>

<H2><A NAME="oop"></A>Object-Oriented Programming</H2>

<BLOCKQUOTE>
<PRE>object( Object, Methods )
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<PRE>/******************************************************************************
                                    OOP
******************************************************************************/

/*=============================================================================
                        Interpreter for OOP
=============================================================================*/

send( Object, Message ) :- get_methods( Object, Methods ),
                           process( Message, Methods ).
                      
get_methods( Object, Methods ) :- object( Object, Methods ).
get_methods( Object, Methods ) :- isa( Object, SuperObject ),
                                  get_methods( SuperObject, Methods ).

process( Message, [Message|_] ).
process( Message, [(Message :- Body)|_] ) :- call( Body ).
process( Message, [_|Methods] ) :- process( Message, Methods ).

/*=============================================================================
                        Geometric Shapes
=============================================================================*/

object( polygon( Sides ), [ (perimeter( P ) :- sum( Sides, P )) ] ).

object( reg_polygon( Side, N ), [ ((perimeter( P ) :- P is N*Side)),
                                  (describe :- write('Regular polygon')) ] ).

                                          
object( rectangle( Length, Width ), 
                 [ (area( A ) :- A is Length * Width ),
                   (describe  :- write('Rectangle of size ' ),
                                 write( Length*Width)) ] ).

object( square( Side ), [ (describe :- write( 'Square with side ' ),
                                       write( Side )) ] ).

object( pentagon( Side ), [ (describe :- write('Pentagon')) ] ).

isa( square( Side ), rectangle( Side, Side ) ).
isa( square( Side ), reg_polygon( Side, 4 ) ).
isa( rectange( Length, Width ), polygon([Length, Width, Length, Width]) ).
isa( pentagon( Side ), reg_polygon( Side, 5 ) ).

isa( reg_polygon( Side, N ), polygon( L ) ) :- makelist( Side, N, L ).
</PRE>
</BLOCKQUOTE>

<H2><A NAME="appendix"></A>Appendix</H2>

<P>The entries in this appendix have the form: <TT>pred/n definition</TT>
where <TT>pred</TT> is the name of the built in predicate, <TT>n</TT> is
its arity (the number of arguments it takes), and <TT>definition</TT> is
a short explanation of the function of the predicate. </P>

<DL>
<DT>ARITHMETIC EXPRESSIONS </DT>

<DL>
<DT>+, -, *, /, sin, cos, tan, atan, sqrt, pow, exp, log</DT>
</DL>

<DT>I/O </DT>

<DL>
<DT>see/1</DT>

<DD>the current input stream becomes arg1 </DD>

<DT>seeing/1</DT>

<DD>arg1 unifies with the name of the current input stream. </DD>

<DT>seen/0</DT>

<DD>close the current input stream </DD>

<DT>tell/1</DT>

<DD>the current output stream becomes arg1 </DD>

<DT>telling/1</DT>

<DD>arg1 unifies with the name of the current output stream. </DD>

<DT>told/0</DT>

<DD>close current output stream </DD>

<DT>read/1</DT>

<DD>arg1 is unified with the next term delimited with a period from the
current input stream. </DD>

<DT>get/1</DT>

<DD>arg1 is unified with the ASCII code of the next printable character
in the current input stream. </DD>

<DT>write/1</DT>

<DD>arg1 is written to the current output stream. </DD>

<DT>writeq/1</DT>

<DD>arg1 is written to the current output stream so that it can be read
with <TT>read</TT>. </DD>

<DT>nl/0</DT>

<DD>an end-of-line character is written to the current output stream. </DD>

<DT>spaces/1</DT>

<DD>arg1 number of spaces is written to the current output stream. </DD>
</DL>

<DT>PROGRAM STATE </DT>

<DL>
<DT>listing/0</DT>

<DD>all the clauses in the Prolog data base are written to the current
output stream </DD>

<DT>listing/1</DT>

<DD>all the clauses in the Prolog data base whose functor name is equal
to arg1 are written to the current output stream </DD>

<DT>clause(H,B)</DT>

<DD>succeeds if H is a fact or the head of some rule in the data base and
B is its body (true in case H is a fact). </DD>
</DL>

<DT>PROGRAM MANIPULATION </DT>

<DL>
<DT>consult/1</DT>

<DD>the file with name arg1 is consulted (loaded into the Prolog data base)
</DD>

<DT>reconsult/1</DT>

<DD>the file with name arg1 is reconsulted </DD>

<DT>assert/1</DT>

<DD>arg1 is interpreted as a clause and is added to the Prolog data base
(functor must be dynamic) </DD>

<DT>retract/1</DT>

<DD>the first clause which is unifiable with arg1 is retracted from the
Prolog data base (functor must be dynamic) </DD>
</DL>

<DT>META-LOGICAL </DT>

<DL>
<DT>ground/1</DT>

<DD>succeeds if arg1 is completely instantiated (BIM) </DD>

<DT>functor/3</DT>

<DD>succeeds if arg1 is a term, arg2 is the functor, and arg3 is the arity
of the term. </DD>

<DT>T =..L</DT>

<DD>succeeds if T is a term and L is a list whose head is the principle
functor of T and whose tail is the list of the arguments of T. </DD>

<DT>name/2</DT>

<DD>succeeds if arg1 is an atom and arg2 is a list of the ASCII codes of
the characters comprising the name of arg1. </DD>

<DT>call/1</DT>

<DD>succeeds if arg1 is a term in the program. </DD>

<DT>setof/3</DT>

<DD>arg3 is a set (list) of all instances of arg1 for which arg2 holds.
Arg3 must be of the form X^T where X is an unbound variables in T other
than arg1. </DD>

<DT>bagof/3</DT>

<DD>arg3 is a list of all instances of arg1 for which arg2 holds. See setof.
</DD>

<DT>\+/1</DT>

<DD>succeeds if arg1 is not provable (Required instead of <B>not</B> in
some Prologs if arg1 contains variables. </DD>

<DT>not/1</DT>

<DD>same as \+ but may requires arg1 to be completely instantiated </DD>
</DL>

<DT>SYSTEM CONTROL </DT>

<DL>
<DT>halt/0, C-d</DT>

<DD>exit from Prolog </DD>
</DL>

<DT>DIRECTIVES </DT>

<DL>
<DT>:- dynamic pred/n .</DT>

<DD>the predicate pred of order n is dynamic </DD>
</DL>
</DL>

<H2><A NAME="ref"></A>References</H2>

<DL>
<DT>Clocksin &amp; Mellish, <I>Programming in Prolog</I> 4th ed. Springer-Verlag
1994. </DT>

<DT>Hill, P. &amp; Lloyd, J. W., <I>The G&ouml;del Programming Language</I>
MIT Press 1994. </DT>

<DT>Hogger, C. J., <I>Introduction to Logic Programming</I> Academic Press
1984. </DT>

<DT>Lloyd, J. W., <I>Foundations of Logic Programming</I> 2nd ed. Springer-Verlag
1987. </DT>

<DT>Nerode, A. &amp; Shore, R. A., <I>Logic for Applications</I> Springer-Verlag
1993. </DT>

<DT>Robinson, J. A., <I>Logic: Form and Function</I> North-Holland 1979.
</DT>

<DT>Sterling and Shapiro, <I>The Art of Prolog</I>. MIT Press, Cambridge,
Mass. 1986. </DT>
</DL>

<P>
<HR>&copy; 1996 by <A HREF="Notices.html">A. Aaby</A>Last Updated: Fri May  2 23:24:37 1997Send comments to: <A HREF="mailto:webmaster@cs.wwc.edu">webmaster@cs.wwc.edu</A></P>

</BODY>
</HTML>
